// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

package topo;

import "google/protobuf/any.proto";

option go_package = "github.com/openconfig/kne/proto/topo";

// Topology message defines what nodes and links will be created
// inside the mesh.
message Topology {
  string name = 1;  // Name of the topology - will be linked to the cluster name
  repeated Node nodes = 2;  // List of nodes in the topology
  repeated Link links = 3;  // connections between Nodes.
}

// Vendor of the node. Topology manager uses this enum to dispatch the node to
// the correct controller.
enum Vendor {
  UNKNOWN = 0;
  HOST = 1;
  ARISTA = 2;
  CISCO = 3;
  JUNIPER = 4;
  KEYSIGHT = 5;
  FRR = 6;
  QUAGGA = 7;
  GOBGP = 8;
  NOKIA = 9;
  OPENCONFIG = 10;
  ALPINE = 11;
  DRIVENETS = 12;
  FORWARD = 13;
}

// Node is a single container inside the topology
message Node {
  reserved 3;
  enum Type {
    UNKNOWN = 0;
    HOST = 1;
    ARISTA_CEOS = 2;
    JUNIPER_CEVO = 3;
    CISCO_CXR = 4;
    QUAGGA = 5;
    FRR = 6;
    JUNIPER_VMX = 7;
    CISCO_CSR = 8;
    NOKIA_SRL = 9;
    IXIA_TG = 10;
    GOBGP = 11;
    CISCO_XRD = 12;
    CISCO_E8000 = 13;
    LEMMING = 14;
  }
  string name = 1;  // Name of the node in the topology. Must be unique.
  Type type = 2 [deprecated = true];
  map<string, string> labels = 4;     // Metadata labels describing the node.
  Config config = 5;                  // Pod specific configuration of the node.
  // Map of services to enable on the node.
  // The key is the external load balancer port to be used by the service.
  // Multiple external services can be mapped to a single internal service port
  // by reusing the inside_port in the service definition.
  map<uint32, Service> services = 6;
  map<string, string> constraints = 7;  // Any k8s constraints required by node.
  Vendor vendor = 8;                    // Vendor enum replaces type.
  string model = 9;                     // Model of the node.
  string version = 10;  // Version string used to identify a software release.
  string os = 11;       // Operating system type.
  // Interfaces is a map of container interfaces used by the node.
  // If interfaces is empty the interfaces defined in the links portion of the
  // topology will be populated into the node.
  map<string, Interface> interfaces = 12;
  // Any host constraints required by the node. These may not be required by a
  // vendor, but it can be used to provide requirements for the node.
  repeated HostConstraint host_constraints = 13;
  // Assigned by KNE.
  // Cluster-internal IP assigned by Kubernetes for the pod.
  // This IP comes from the worker node's IP pool.
  string pod_ip = 14;
}

// HostConstraint is a constraint on the host where the node is running.
message HostConstraint {
  oneof constraint {
    // Includes the required kernel parameters that need to be configured.
    KernelParam kernel_constraint = 1;
  }
}

// KernelParam is a parameter on the host kernel.
message KernelParam {
  // MIB style name of the kernel state to constrain.
  string name = 1;
  oneof ConstraintType {
    BoundedInteger bounded_integer = 2;
  }
}

// BoundedInteger to capture the range of max or min for a particular
// constraint.
message BoundedInteger {
  int64 max_value = 1;
  int64 min_value = 2;
}

// Interface keys must be the same as the links a,z int.
message Interface {
  enum InterfaceType {
    UNKNOWN = 0;
    LOOPBACK = 1;
    MANAGEMENT = 2;
    DATA = 3;
  }
  // Name of the interface provided by Node implementation. This will be used
  // to map the int_name into a vendor specific interface name. Vendor operators
  // should provide the name mapping from the node interface key to this vendor
  // specific name.
  string name = 1;
  // Internal device name. This name matches the key in the Node interface map.
  // It will be returned by the operator. Assigned by KNE.
  string int_name = 2;
  uint32 mtu = 3;  // Desired MTU for the interface.
  // Peer node name. Assigned by KNE.
  string peer_name = 4;
  // Peer interface name. Assigned by KNE.
  string peer_int_name = 5;
  // Uid is the internal link identifier used by Meshnet.
  int64 uid = 6;
  // Name of group to which this interface belongs
  string group = 7;
  // Type of the interface - Loopback, Management , Data etc.
  InterfaceType type = 8;
  // ip_address associated with the interface.
  string ip_address = 9;
}

// Link is single link between nodes in the topology.
// Interfaces must start eth1 - eth0 is the default k8s interface.
message Link {
  string a_node = 1;
  string a_int = 2;
  string z_node = 3;
  string z_int = 4;
}

// Config is the k8s pod specific configuration for a node.
message Config {
  repeated string command = 1;  // Command to pass into pod.
  repeated string args = 2;     // Command args to pass into the pod.
  string image = 3;             // Docker image to use with pod.
  // Map of environment variables to pass into the pod.
  map<string, string> env = 4;
  // Specific entry point command for accessing the pod.
  string entry_command = 5;
  // Mount point for configuration inside the pod.
  string config_path = 6;
  // Default configuration file name for the pod.
  string config_file = 7;
  uint32 sleep = 8;  // Sleeptime before starting the pod.
  // Certificate configuration
  CertificateCfg cert = 9;
  oneof config_data {
    // Byte data for the startup configuration file.
    bytes data = 101;
    // File is always relative to the topology configuration file.
    string file = 102;
  }
  // Docker image to use as an init container for the pod.
  string init_image = 10;
  // Vendor-specific data
  google.protobuf.Any vendor_data = 11;
}

message CertificateCfg {
  oneof config {
    // self_signed will generate local certificates on the node.
    SelfSignedCertCfg self_signed = 1;
    // Additional options will be for loading pregenerated certs.
    // Also support for CSR and generation workflow.
  }
}

message SelfSignedCertCfg {
  // Certificate name on the node.
  string cert_name = 1;
  // Key name on the node.
  string key_name = 2;
  // RSA keysize to use for key generation.
  uint32 key_size = 3;
  // Common name to set in the cert.
  string common_name = 4;
}

// Service is k8s Service to exposed to the cluster. The initial input can be
// provided by the user for which services they would like exposed. Once the
// service is created KNE will fill in the outside information for the user to
// access the services.
// The user should specify inside port for this is the port the container will
// listen on.
message Service {
  string name = 1;        // Name of the service (optional)
  uint32 inside = 2;      // Inside port to map Node (container listening port)

  // Assigned by KNE.
  uint32 outside = 3;     // Outside port used by service. (same a service key)
  string outside_ip = 5;  // External IP assigned by cluster load balancer.

  // Used internally by KNE.
  string inside_ip = 4;   // Cluster IP for the service.
  uint32 node_port = 6;   // Port on the K8s worker node used by the cluster.

  // List of service names to be mapped to the port (optional).
  // If only one field out of "name" or "names" is provided in the input topo,
  // the unspecified field is ignored.
  // If both are provided, names in both fields are considered excluding any
  // duplicate values.
  repeated string names = 7;
}
